input {
  redis {
    host => "localhost"
    type => "redis-input"
    data_type => "list"
    key => "logstash"
    codec => plain
  }
}

################
# alfresco.log #
################
filter {
  if [type] == "alfrescoLog" {
    multiline {
      pattern => "(^\d\d\d\d-\d\d-\d\d \d\d:\d\d:\d\d,\d\d\d)"
      negate => true
      what => "previous"
    }

    mutate {
      gsub => [
        # replace double blank space with single blank space
        "message", "  ", " "
      ]
    }

    grok {
      match => [ "message", "%{TIMESTAMP_ISO8601:logdate} %{LOGLEVEL:logLevel} %{NOTSPACE:class} %{GREEDYDATA:data}" ]
      add_tag => [ "%{logLevel}" ]
      add_field => [ "classMsg", "%{class} %{data}" ]
    }

    date {
       match => ["logdate" , "yyyy-MM-dd HH:mm:ss,SSS"]
       target => "@timestamp"
    }

    grok {
      match => [ "message", "Exception" ]
      add_tag => [ "Exception"]
    }

    grok {
      match => [ "message", "NullPointerException" ]
      add_tag => [ "NullPointerException"]
    }

    grok {
      match => [ "message", "OutOfMemoryError" ]
      add_tag => [ "OutOfMemoryError"]
    }

    grok {
      match => [ "message", "Too many open files" ]
      add_tag => [ "TooManyOpenFiles"]
    }
  }
}

################
# share.log #
################
filter {
  if [type] == "shareLog" {
    multiline {
      pattern => "(^\d\d\d\d-\d\d-\d\d \d\d:\d\d:\d\d,\d\d\d)"
      negate => true
      what => "previous"
    }

    mutate {
      gsub => [
        # replace double blank space with single blank space
        "message", "  ", " "
      ]
    }

    grok {
      match => [ "message", "%{TIMESTAMP_ISO8601:logdate} %{LOGLEVEL:logLevel} %{NOTSPACE:class} %{GREEDYDATA:data}" ]
      add_tag => [ "%{logLevel}" ]
      add_field => [ "classMsg", "%{class} %{data}" ]
    }

    date {
       match => ["logdate" , "yyyy-MM-dd HH:mm:ss,SSS"]
       target => "@timestamp"
    }

    grok {
      match => [ "message", "Exception" ]
      add_tag => [ "Exception"]
    }

    grok {
      match => [ "message", "NullPointerException" ]
      add_tag => [ "NullPointerException"]
    }

    grok {
      match => [ "message", "OutOfMemoryError" ]
      add_tag => [ "OutOfMemoryError"]
    }

    grok {
      match => [ "message", "Too many open files" ]
      add_tag => [ "FileHandles"]
    }
  }
}


################
# solr.log #
################
filter {
  if [type] == "solrLog" {
    multiline {
        type => "solrLog"
        pattern => "(^\d\d\d\d-\d\d-\d\d \d\d:\d\d:\d\d,\d\d\d)"
        negate => true
        what => "previous"
    }

    mutate {
      gsub => [
      # replace double blank space with single blank space
      "message", "  ", " "
      ]
    }

    grok {
      match => [ "message", "%{TIMESTAMP_ISO8601:logdate} %{LOGLEVEL:logLevel} %{NOTSPACE:class} %{GREEDYDATA:data}" ]
      add_tag => [ "%{logLevel}" ]
      add_field => [ "classMsg", "%{class} %{data}" ]
    }

    date {
       match => ["logdate" , "yyyy-MM-dd HH:mm:ss,SSS"]
       target => "@timestamp"
    }

    grok {
      match => [ "message", "Exception" ]
      add_tag => [ "Exception"]
    }

    grok {
      match => [ "message", "NullPointerException" ]
      add_tag => [ "NullPointerException"]
    }

    grok {
      match => [ "message", "OutOfMemoryError" ]
      add_tag => [ "OutOfMemoryError"]
    }

    grok {
      match => [ "message", "Too many open files" ]
      add_tag => [ "FileHandles"]
    }
  }
}


#############
# audit.log #
#############
filter {
  if [type] == "auditLog" {
    grep {
      match => [ "message", "(.+count.+:.+)|(.+entries.+:.+)" ]
      negate => true
    }

    grep {
      match => [ "message", "(.+:.+)" ]
    }

    multiline {
      pattern => "(^.+\"id\":\d.+,)"
      negate => true
      what => "previous"
    }

    grok {
      match => [ "message", "%{TIMESTAMP_ISO8601:logdate}%{ISO8601_TIMEZONE}" ]
    }

    date {
       match => [ "logdate", "yyyy-MM-dd'T'HH:mm:ss.SSS" ]
       timezone => "Europe/London"
       target => "@timestamp"
    }
  }
}

#########################
# DB: files by mimetype #
#########################
filter {
  if [type] == "dbFilesMimetype" {
    grep {
      match => [ "message", "^$" ]
      negate => true
    }

    mutate {
      gsub => [
        # remove spaces
        "message", " ", "",

        # replace backslash with space
        "message", "\|", " "
      ]
    }

    grok {
      pattern => "%{WORD:mimetype} %{NUMBER:size} %{NUMBER:occurrencies}"
      add_tag => [ "%{dbFilesMimetype}" ]
    }
  }
}

#########################
# DB: files per store   #
#########################
filter {
  if [type] == "dbFilesPerStore" {
    grep {
      match => [ "message", "^$" ]
      negate => true
    }

    mutate {
      gsub => [
        # remove spaces
        "message", " ", "",
  
        # replace backslash with space
        "message", "\|", " "
      ]
    }

    grok {
      pattern => "%{NUMBER:count} %{NOTSPACE:store}"
      add_tag => [ "%{dbFilesPerStore}" ]
    }
  }
}

###########################
# output to elasticsearch #
###########################

output {
  stdout { codec => rubydebug }

  elasticsearch {
    host => "localhost"
    port => "9300"
    cluster => "elasticsearch-kibana"
  }
}
